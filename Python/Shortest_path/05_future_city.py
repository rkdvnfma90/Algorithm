"""
미래도시 문제
방문판매원 A는 많은 회사가 모여있는 공중 미래 도시에 있다. 여기에는 1번부터 n번까지의 회사가 있는데, 특정 회사끼리는 서로 도로를 통해 연결되어 있다.
A는 현재 1번회사에 있으며 x번 회사에 방문하여 물건을 팔고자 한다. 연결된 두 회사는 양방향으로 이동할 수 있다. 두 회사의 거리는 1이라고 한다.
또한 A는 x번 회사에 가기전에 k번 회사에 들러 업무를 처리하고 가야한다. 이때 A는 가능한 ㅂ한 빠르게 이동하고자 한다.
방문 판매원이 회사 사이를 이동하게 되는 최소시간을 계산하는 프로그램을 작성하시오.
예를들어 n = 5 , x = 4, k = 5 이고 회사간 도로가 총 7개 일 경우 아래와 같이 도로가 연결되어 있다.
(1, 2), (1, 3), (1, 4), (2, 4), (3, 4), (3, 5),(4, 5)
이때 4번회사에 가는 경로를 1 -> 3 -> 5 -> 4 번으로 설정하면 총 3만큼의 시간으로 이동할 수 있다.

입력조건
1. 첫째줄에 전체 회사의 갯수 n과 경로의 갯수 m이 입력된다 (1 <= n, m <= 100)
2. 둘째줄부터 m + 1 번째 줄에는 연결된 두 회사의 번호가 공백으로 구분되어 주어진다.
3. m + 2 번째 줄에는 x와 k가 공백으로 구분되어 차례대로 주어진다 (1 <= k <= 100)

출력조건
1. 판매원 A가 k번 회사를 거쳐 x번 회사로 가는 최소 이동 시간을 출력한다.
2. 만약 x에 도달할 수 없으면 -1을 출력한다.

입력예시 1
5 7
1 2
1 3
1 4
2 4
3 4
3 5
4 5
4 5

출력예시 1
3

---
입력예시 2
4 2
1 3
2 4
3 4

출력예시 2
-1


해당문제는 전형적인 플로이드 워셜 알고리즘 문제이다.
n의 범위가 100 이하로 매우 한정적이다. 따라서 플로이드 워셜 알고리즘을 이용하는것이 유리하다.
핵심은 1번노드에서 k를 거쳐 x로 가는 최단거리는 1 -> k + k -> x 이다

"""

INF = int(1e9)

# n : 노드(회사) 갯수, m : 간선(길) 갯수
n, m = map(int, input().split())

# 비용 정보를 가지고 있는 2차원 그래프의 모든값은 무한으로 초기화
graph = [[INF] * (n + 1) for i in range(n + 1)]

# 자기 자신에게 이동하는 경로는 1로 초기화 (2차원 배열상 행과 열의 인덱스가 같을 경우임)
for a in range(n + 1):
  for b in range(n + 1):
    if a == b:
      graph[a][b] = 0


# 연결된 두 회사의 번호가 공백으로 주어진다. 예를들어 1 2 입력하였을때 1에서 2로 가는 거리는 1인셈.
# 간선의 수만큼 반복한다.
for _ in range(m):
  a, b = map(int, input().split())
  # 해당 문제의 경우 양방향으로 이동할 수 있기에 행과 열을 바꾼 값 또한 1로 세팅해준다.
  graph[a][b] = 1
  graph[b][a] = 1


# x : 목적지 노드, k : 경유지 노드
x, k = map(int, input().split())


# 플로이드 워셜 알고리즘
for z in range(1, n + 1):
  for a in range(1, n + 1):
    for b in range(1, n + 1):
      graph[a][b] = min(graph[a][b], graph[a][z] + graph[z][b]) 


result = graph[1][k] + graph[k][x]

if result >= INF:
  print("-1")
else:
  print(result)
