"""
효율적인 화폐구성
n가지 종류의 화폐가 있다. 이 화폐들의 갯수를 최소한으로 이용해서 그 가치의 합이 m원이 되도록 하려 한다.
각 화폐는 몇개라도 사용할 수 있으며 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.
예를들어 2원 3원의 화폐가 있을때 15원을 만들기 위해서는 3원짜리 5개 를 사용하는것이 최소한의 화폐 갯수 이다.

입력조건
1. 첫째 줄에 n,m이 주어진다 (1 <= n <= 100, 1 <= m <= 10,000)
2. 이후 n 개의 줄에는 화폐의 가치가 주어진다. (10,000 보다 작거나 같은 자연수)

출력조건
1. 경우의 수 x를 출력한다.
2. 불가능할 때에는 -1을 출력한다.
"""

# n, m 입력
n, m = map(int, input().split())

# n개의 화폐단위 정보를 초기화 한다.
arr = []
for i in range(n):
    arr.append(int(input()))

# 한번 계산된 값을 넣기위한 DP 테이블 초기화
# 해당 DP 테이블의 인덱스는 금액을 의미한다. 값은 해당 금액을 만들기 위해 필요한 최적의 화폐 갯수 이다.
# 10001 로 초기화 하는 이유는 m이 10,000 범위 안에 존재해야 하므로 INF 의 의미이다.
# m + 1 의 의미는 인덱스가 0부터 시작하므로 + 1
d = [10001] * (m + 1)

# 화폐를 하나도 사용하지 않았을때 0원은 화폐 0개를 써서 만들수 있으므로 초기화
d[0] = 0

# 화폐의 수 만큼 반복
for i in range(n):
    # 현재 화폐값 부터 사용자가 원하는 값 (m) 까지 반복하여 화폐 수를 구한다
    for j in range(arr[i], m + 1):
        # i - k 원을 만들 방법이 존재한다면 현재 인덱스 j - 화폐 arr[i] 의 인덱스 값에 1을 더한다 (화폐로 만들수 있기 때문)
        if d[j - arr[i]] != 10001:
            d[j] = min(d[j], d[j - arr[i]] + 1)

# 불가능일 경우 -1 
if d[m] == 10001:
    print(-1)
else:
    print(d[m])

