"""
위상정렬
순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘 이다.
위상정렬의 특징
1. 순환하지 않는 방향 그래프에서만 수행할 수 있다.
2. 위상정렬에는 여러가지 답이 존재할 수 있다. (한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우가 있다면..)
3. 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있다.
4. 스택을 활용한 DFS를 이용하여 위상 정렬을 수행할 수 있다.

-> 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열 하는 것
위상정렬 알고리즘을 살펴보기 전에 진입차수 먼저 알아야 한다.
진입차수란 특정한 노드로 들어오는 간선의 개수를 의미한다.

1. 진입차수가 0인 노드를 큐에 넣는다
2. 큐가 빌때까지 다음의 과정을 반복한다
    ㄱ. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다
    ㄴ. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.
"""

# 위상정렬은 큐를 이용해야 하므로 덱을 임포트 한다
from collections import deque

# 노드의 개수와 간선의 개수를 입력받는다
v, e = map(int, input().split())
# 모든 노드에 대한 진입차수는 0으로 초기화 한다
indegree = [0] * (v + 1)
# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트(그래프) 초기화
graph = [[] for i in range(v + 1)]

# 방향 그래프의 모든 간선 정보를 입력 받기
for _ in range(e):
    a, b = map(int, input().split())
    # 정점 a에서 b로 이동이 가능하다는 의미
    graph[a].append(b)
    # a에서 b로 이동이 가능하다는 말은 b의 진입차수가 하나씩 증가한다는 의미이므로 1을 증가시킨다.
    indegree[b] += 1


# 위상 정렬 함수
def toplogy_sort():
    # 알고리즘 수행 결과를 담을 리스트
    result = []
    q = deque()

    # 처음 시작할때는 진입차수가 0인 노드를 큐에 삽입한다.
    for i in range(1, v + 1):
      if indegree[i] == 0:
        q.append(i)
    
      # 큐가 빌때까지 반복 한다.
    while q:
      # 큐에서 원소 꺼내어 결과 리스트에 넣는다.
      now = q.popleft()
      result.append(now)

      # 현재 해당하는 원소와 연결된 노드들의 진입차수에서 1을 뺀다. 왜냐하면 해당 원소 now가 큐에서 pop 되어 결과 리스트로 들어갔기 때문
      for i in graph[now]:
        indegree[i] -= 1
        # 새롭게 진입차수가 0이 되는 노드를 큐에 삽입
        if indegree[i] == 0:
          q.append(i)
    # 위상정렬을 수행한 결과 출력
    for i in result:
      print(i, end = ' ')
    
    

toplogy_sort()